/*
 * MAX RESTful API List
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package api

import (
	"context"
	"io/ioutil"
	"net/url"
	"net/http"
	"strings"
	"encoding/json"
	"fmt"
)

// Linger please
var (
	_ context.Context
)

type PublicApiService service


/* PublicApiService 
 get all available currencies.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return []Currency*/
func (a *PublicApiService) GetApiV2Currencies(ctx context.Context) ([]Currency,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  []Currency
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/currencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})


	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PublicApiService 
 get depth of a specified market, sorted from highest price to lowest
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param market unique market id, check /api/v2/markets for available markets
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "limit" (int32) returned price levels limit, default to 300
 @return */
func (a *PublicApiService) GetApiV2Depth(ctx context.Context, market string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/depth"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	return a.client.callAPI(r)
}

/* PublicApiService 
 get OHLC(k line) of a specific market
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param market unique market id, check /api/v2/markets for available markets
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "limit" (int32) returned data points limit, default to 30
     @param "period" (int32) time period of K line in minute, default to 1
     @param "timestamp" (int32) the seconds elapsed since Unix epoch, set to return data after the timestamp only
 @return */
func (a *PublicApiService) GetApiV2K(ctx context.Context, market string, localVarOptionals map[string]interface{}) ( *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/k"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["period"], "int32", "period"); err != nil {
		return nil, err
	}
	if err := typeCheckParameter(localVarOptionals["timestamp"], "int32", "timestamp"); err != nil {
		return nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["period"].(int32); localVarOk {
		localVarQueryParams.Add("period", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["timestamp"].(int32); localVarOk {
		localVarQueryParams.Add("timestamp", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	return a.client.callAPI(r)
}

/* PublicApiService 
 get all available markets.
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return []Market*/
func (a *PublicApiService) GetApiV2Markets(ctx context.Context) ([]Market,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  []Market
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/markets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})


	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PublicApiService 
 get the order book of a specified market
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param market unique market id, check /api/v2/markets for available markets
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "asksLimit" (int32) returned sell orders limit, default to 20
     @param "bidsLimit" (int32) returned buy orders limit, default to 20
 @return OrderBook*/
func (a *PublicApiService) GetApiV2OrderBook(ctx context.Context, market string, localVarOptionals map[string]interface{}) (OrderBook,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  OrderBook
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/order_book"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["asks_limit"], "int32", "asks_limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["bids_limit"], "int32", "bids_limit"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["asks_limit"].(int32); localVarOk {
		localVarQueryParams.Add("asks_limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["bids_limit"].(int32); localVarOk {
		localVarQueryParams.Add("bids_limit", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PublicApiService 
 get ticker of all markets
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return Tickers*/
func (a *PublicApiService) GetApiV2Tickers(ctx context.Context) (Tickers,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Tickers
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/tickers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})


	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PublicApiService 
 get ticker of specific market
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param market unique market id, check /api/v2/markets for available markets
 @return Ticker*/
func (a *PublicApiService) GetApiV2TickersMarket(ctx context.Context, market string) (Ticker,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  Ticker
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/tickers/{market}"
	localVarPath = strings.Replace(localVarPath, "{"+"market"+"}", fmt.Sprintf("%v", market), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})


	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

/* PublicApiService 
 get server current time, in seconds since Unix epoch
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @return */
func (a *PublicApiService) GetApiV2Timestamp(ctx context.Context) ( *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/timestamp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})


	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	return a.client.callAPI(r)
}

/* PublicApiService 
 get recent trades on market, sorted in reverse creation order
 * @param ctx context.Context for authentication, logging, tracing, etc.
 @param market unique market id, check /api/v2/markets for available markets
 @param optional (nil or map[string]interface{}) with one or more of:
     @param "timestamp" (int32) the seconds elapsed since Unix epoch, set to return trades executed before the time only
     @param "from" (int32) trade id, set ot return trades created after the trade
     @param "to" (int32) trade id, set to return trades created before the trade
     @param "orderBy" (string) order the trades by created time, default to &#39;desc&#39;
     @param "pagination" (bool) do pagination &amp; return metadata in header (default true)
     @param "page" (int32) page number, applied for pagination (default 1)
     @param "limit" (int32) returned limit (1~1000, default 50)
     @param "offset" (int32) records to skip, not applied for pagination (default 0)
 @return []Trade*/
func (a *PublicApiService) GetApiV2Trades(ctx context.Context, market string, localVarOptionals map[string]interface{}) ([]Trade,  *http.Response, error) {
	var (
		localVarHTTPMethod = strings.ToUpper("Get")
		localVarFileName string
		localVarFileBytes []byte
	 	successPayload  []Trade
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v2/trades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	localVarPostBody := make(map[string]interface{})

	if err := typeCheckParameter(localVarOptionals["timestamp"], "int32", "timestamp"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["from"], "int32", "from"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["to"], "int32", "to"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["order_by"], "string", "order_by"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["pagination"], "bool", "pagination"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["page"], "int32", "page"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["limit"], "int32", "limit"); err != nil {
		return successPayload, nil, err
	}
	if err := typeCheckParameter(localVarOptionals["offset"], "int32", "offset"); err != nil {
		return successPayload, nil, err
	}

	localVarQueryParams.Add("market", parameterToString(market, ""))
	if localVarTempParam, localVarOk := localVarOptionals["timestamp"].(int32); localVarOk {
		localVarQueryParams.Add("timestamp", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["from"].(int32); localVarOk {
		localVarQueryParams.Add("from", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["to"].(int32); localVarOk {
		localVarQueryParams.Add("to", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["order_by"].(string); localVarOk {
		localVarQueryParams.Add("order_by", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["pagination"].(bool); localVarOk {
		localVarQueryParams.Add("pagination", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["page"].(int32); localVarOk {
		localVarQueryParams.Add("page", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["limit"].(int32); localVarOk {
		localVarQueryParams.Add("limit", parameterToString(localVarTempParam, ""))
	}
	if localVarTempParam, localVarOk := localVarOptionals["offset"].(int32); localVarOk {
		localVarQueryParams.Add("offset", parameterToString(localVarTempParam, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{  }

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{
		"application/json",
		}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return successPayload, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return successPayload, localVarHTTPResponse, err
	}
	defer localVarHTTPResponse.Body.Close()
	if localVarHTTPResponse.StatusCode >= 300 {
		bodyBytes, _ := ioutil.ReadAll(localVarHTTPResponse.Body)
		return successPayload, localVarHTTPResponse, reportError("Status: %v, Body: %s", localVarHTTPResponse.Status, bodyBytes)
	}


	if err = json.NewDecoder(localVarHTTPResponse.Body).Decode(&successPayload); err != nil {
		return successPayload, localVarHTTPResponse, err
	}

	return successPayload, localVarHTTPResponse, err
}

